-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ZynqBF_2tx_fpga\ZynqBF_2t_ip_src_peakdetect_ch1.vhd
-- Created: 2019-02-08 23:33:51
-- 
-- Generated by MATLAB 9.5 and HDL Coder 3.13
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ZynqBF_2t_ip_src_peakdetect_ch1
-- Source Path: ZynqBF_2tx_fpga/channel_estimator/peakdetect_ch1
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ZynqBF_2t_ip_src_ZynqBF_2tx_fpga_pkg.ALL;

ENTITY ZynqBF_2t_ip_src_correlators IS
  GENERIC(
        NCORR                             :   integer := 2      -- number of correlators
        );
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        rst                               :   IN    std_logic;
        din_i                             :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15 [2]
        din_q                             :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15 [2]
        vin                               :   IN    std_logic;                      -- rx ram write enable
        est_en                            :   IN    std_logic;
        index                             :   OUT   std_logic_vector(14 DOWNTO 0);  -- ufix15
        step                              :   OUT   std_logic;
        peak_found                        :   OUT   std_logic;
        est_val                           :   OUT   std_logic;                      -- valid signal for ch_est input
        probe                             :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En16
        );
END ZynqBF_2t_ip_src_correlators;


ARCHITECTURE rtl OF ZynqBF_2t_ip_src_correlators IS

  -- Component Declarations
  COMPONENT ZynqBF_2t_ip_src_peak_fsm
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          t_cross                         :   IN    std_logic;
          cnt_end                         :   IN    std_logic;
          scan_peak                       :   OUT   std_logic;
          peak_found                      :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ZynqBF_2t_ip_src_running_max
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          din                             :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En16
          en                              :   IN    std_logic;
          rst                             :   IN    std_logic;
          new_max                         :   OUT   std_logic;
          max_val                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En16
          );
  END COMPONENT;

  -- COMPONENT ZynqBF_2t_ip_src_store_index
    -- PORT( clk                             :   IN    std_logic;
          -- reset                           :   IN    std_logic;
          -- enb                             :   IN    std_logic;
          -- din                             :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
          -- update                          :   IN    std_logic;
          -- dout                            :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          -- );
  -- END COMPONENT;
  
  component ZynqBF_2t_ip_src_rx_bram 
  port( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        din_i                             :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        din_q                             :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        we                                :   IN    std_logic;
        wr_addr                           :   IN    std_logic_vector(14 DOWNTO 0);  -- ufix15
        rd_addr                           :   IN    std_logic_vector(14 DOWNTO 0);  -- ufix15
        shift                             :   IN    std_logic_vector(5 DOWNTO 0);  -- ufix15
        dout_i                            :   OUT   vector_of_std_logic_vector16(0 TO 63);  -- rx i data for the correlators
        dout_q                            :   OUT   vector_of_std_logic_vector16(0 TO 63)   -- rx q data for the correlators
        );
  END COMPONENT;
  
  component ZynqBF_2t_ip_src_goldSeq
  generic (N                              :   integer := 2);
  port( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        addr                              :   IN    std_logic_vector(5 DOWNTO 0);
        gs_out                            :   OUT   vector_of_std_logic_vector16(0 to (N*64 - 1))
        );
  end component;
  
  component ZynqBF_2t_ip_src_shift_rx
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        u                                 :   IN    vector_of_std_logic_vector16(0 TO 63);  -- sfix16_En15 [64]
        shift                             :   IN    std_logic_vector(5 DOWNTO 0);  -- ufix6
        y                                 :   OUT   vector_of_std_logic_vector16(0 TO 63)  -- sfix16_En15 [64]
        );
  END component;
  
  component ZynqBF_2t_ip_src_rx_gs_mult
  generic( N                              :   integer := 2);
  port( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        en                                :   IN    std_logic;  -- enable for MACC
        rxi                               :   IN    vector_of_std_logic_vector16(0 TO 63);  -- rx i data for the correlators
        rxq                               :   IN    vector_of_std_logic_vector16(0 TO 63);  -- rx q data for the correlators
        gsi                               :   IN    vector_of_std_logic_vector16(0 TO (64*N-1));  -- gs i data for the correlators
        gsq                               :   IN    vector_of_std_logic_vector16(0 TO (64*N-1))   -- gs q data for the correlators
        );
  end component;
        

  -- Component Configuration Statements
  FOR ALL : ZynqBF_2t_ip_src_peak_fsm
    USE ENTITY work.ZynqBF_2t_ip_src_peak_fsm(rtl);

  FOR ALL : ZynqBF_2t_ip_src_running_max
    USE ENTITY work.ZynqBF_2t_ip_src_running_max(rtl);

  --FOR ALL : ZynqBF_2t_ip_src_store_index
  --  USE ENTITY work.ZynqBF_2t_ip_src_store_index(rtl);
    
  FOR ALL : ZynqBF_2t_ip_src_rx_bram
    USE ENTITY work.ZynqBF_2t_ip_src_rx_bram(rtl);
    
  FOR ALL : ZynqBF_2t_ip_src_goldSeq
    USE ENTITY work.ZynqBF_2t_ip_src_goldSeq(rtl);  
    
  FOR ALL : ZynqBF_2t_ip_src_shift_rx
    USE ENTITY work.ZynqBF_2t_ip_src_shift_rx(rtl);
    
  FOR ALL : ZynqBF_2t_ip_src_rx_gs_mult
    USE ENTITY work.ZynqBF_2t_ip_src_rx_gs_mult(rtl);

  -- Signals
  SIGNAL addr_unsigned                    : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL Delay9_reg                       : vector_of_unsigned15(0 TO 1);  -- ufix15 [2]
  SIGNAL Delay9_out1                      : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL Add1_sub_temp                    : signed(16 DOWNTO 0);  -- sfix17
  SIGNAL Add1_out1                        : signed(15 DOWNTO 0);  -- int16
  SIGNAL index_in                         : signed(15 DOWNTO 0);  -- int16
  SIGNAL corr_vout                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL correlator1_out2                 : std_logic;
  SIGNAL correlator1_out3                 : std_logic;
  SIGNAL corr_vout_signed                 : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL Delay4_out1                      : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL peak_fsm_out1                    : std_logic;
  SIGNAL Logical_Operator5_out1           : std_logic;
  SIGNAL count_20_steps_out1              : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Compare_To_Constant1_out1        : std_logic;
  SIGNAL Logical_Operator7_out1           : std_logic;
  SIGNAL peak_fsm_out2                    : std_logic;
  SIGNAL update_index                     : std_logic;
  SIGNAL running_max_out2                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL stored_index                     : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL stored_index_signed              : signed(15 DOWNTO 0);  -- int16
  SIGNAL Data_Type_Conversion_out1        : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL Delay10_out1                     : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL Logical_Operator3_out1           : std_logic;
  SIGNAL Logical_Operator2_out1           : std_logic;
  SIGNAL Delay3_out1                      : std_logic;
  SIGNAL Delay6_out1                      : std_logic;
  
  signal rxi                              : vector_of_std_logic_vector16(0 to 63);
  signal rxq                              : vector_of_std_logic_vector16(0 to 63);
  signal gsdata                           : vector_of_std_logic_vector16(0 to (64*NCORR - 1));
  signal gsi                              : vector_of_std_logic_vector16(0 to (64*NCORR - 1));
  signal gsq                              : vector_of_std_logic_vector16(0 to (64*NCORR - 1));
  signal rxi_shifted                      : vector_of_std_logic_vector16(0 to 63);
  signal rxq_shifted                      : vector_of_std_logic_vector16(0 to 63);
  
  
  signal vin_dreg                         : std_logic_vector(2 downto 0);   -- 3 stage delay register for vin signal
  signal inc_rx_ram_wraddr                : std_logic;                      -- flag to increment the rx ram wr addr
  
  signal corr_start                       : std_logic;
  signal corr_done                        : std_logic;
  signal corr_en                          : std_logic;
  signal corr_en_d3                       : std_logic;
  signal corr_en_dreg                     : std_logic_vector(2 downto 0);   -- 3 stage delay register for corr en signal
  signal rx_ram_re                        : std_logic;
  signal rx_ram_wraddr                    : std_logic_vector(14 downto 0);
  signal rx_ram_rdaddr                    : std_logic_vector(14 downto 0);
  signal gs_ram_rdaddr                    : std_logic_vector(5 downto 0);
  signal rx_in_addr                       : unsigned(14 downto 0);
  signal shift_cnt                        : unsigned(5 downto 0);
  
  signal corr_shift                       : unsigned(5 downto 0);           -- latch value of shift_cnt at the start of the correlation
  signal corr_cnt                         : unsigned(11 downto 0);          -- correlation counter (and address for gs ram, address offset for rx ram)
  signal corr_base                        : unsigned(14 downto 0);          -- correlation base address for rx ram

BEGIN

  gsi <= gsdata;
  gsq <= gsdata;

  u_rx_bram : ZynqBF_2t_ip_src_rx_bram
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              din_i => din_i,
              din_q => din_q,
              we => vin,
              wr_addr => rx_ram_wraddr,
              rd_addr => rx_ram_rdaddr,
              shift => std_logic_vector(corr_shift),
              dout_i => rxi,
              dout_q => rxq
              );
              
  u_gs : ZynqBF_2t_ip_src_goldSeq
    GENERIC MAP (N => NCORR)
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              addr => gs_ram_rdaddr,
              gs_out => gsdata
              );
              
  u_shift_rxi : ZynqBF_2t_ip_src_shift_rx
    PORT MAP( clk => clk,
              reset => reset,
              u => rxi,
              shift => std_logic_vector(corr_shift),
              y => rxi_shifted
              );
  
  u_shift_rxq : ZynqBF_2t_ip_src_shift_rx
    PORT MAP( clk => clk,
              reset => reset,
              u => rxq,
              shift => std_logic_vector(corr_shift),
              y => rxq_shifted
              );
  
  test_macc : ZynqBF_2t_ip_src_rx_gs_mult
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              en => corr_en_d3,
              rxi => rxi_shifted,
              rxq => rxq_shifted,
              gsi => gsi,
              gsq => gsq
              );

  u_peak_fsm : ZynqBF_2t_ip_src_peak_fsm
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              t_cross => Compare_To_Constant_out1,
              cnt_end => Logical_Operator7_out1,
              scan_peak => peak_fsm_out1,
              peak_found => peak_fsm_out2
              );

  u_running_max : ZynqBF_2t_ip_src_running_max
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              din => std_logic_vector(Delay4_out1),  -- sfix32_En16
              en => peak_fsm_out1,
              rst => peak_fsm_out2,
              new_max => update_index,
              max_val => running_max_out2  -- sfix32_En16
              );

  vin_delay_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            vin_dreg <= "000";
        elsif enb = '1' then
            vin_dreg <= vin_dreg(1 downto 0) & vin;
        end if;
    end if;
  end process;
  
  corr_start <= vin_dreg(1);
  inc_rx_ram_wraddr <= vin_dreg(2);
  
  addr_in_counters_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' or rst = '1' then
            rx_in_addr <= (others => '0');
            shift_cnt <= (others => '0');
        elsif enb = '1' and inc_rx_ram_wraddr = '1' then
            if rx_in_addr = "111000000000000" then
                rx_in_addr <= (others => '0');
            else
                rx_in_addr <= rx_in_addr + 1;
            end if;
            shift_cnt <= shift_cnt + 1;
        end if;
    end if;
  end process;
  
  rx_ram_wraddr <= std_logic_vector(rx_in_addr + "000111111111111");
  
  correlation_enable_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            corr_en <= '0';
        elsif enb = '1' then
            if corr_done = '1' then
                corr_en <= '0';
            elsif corr_start = '1' then
                corr_en <= '1';
            end if;
        end if;
    end if;
  end process;
  
  corr_en_delay_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            corr_en_dreg <= "000";
        elsif enb = '1' then
            corr_en_dreg <= corr_en_dreg(1 downto 0) & corr_en;
        end if;
    end if;
  end process;
  
  corr_en_d3 <= corr_en_dreg(2);
  
  correlation_control_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            corr_shift <= (others => '0');
            corr_cnt <= (others => '0');
            corr_base <= (others => '0');
        elsif enb = '1' then
            if corr_start = '1' then
                corr_shift <= shift_cnt;
                corr_cnt <= (others => '0');
                corr_base <= rx_in_addr;
            elsif corr_en = '1' then
                corr_shift <= corr_shift;
                corr_cnt <= corr_cnt + 64;  -- increment by the number of parallel DSPs for each correlator iteration
                corr_base <= corr_base;
            else
                corr_shift <= corr_shift;
                corr_cnt <= (others => '0');
                corr_base <= corr_base;
            end if;
        end if;
    end if;
  end process;
  
  corr_done <= '1' when corr_cnt(11 downto 6) = 63 else '0';
  gs_ram_rdaddr <= std_logic_vector(corr_cnt(11 downto 6));
  rx_ram_rdaddr <= std_logic_vector(corr_cnt + corr_base);

  Delay9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay9_reg <= (OTHERS => to_unsigned(16#0000#, 15));
      ELSIF enb = '1' THEN
        Delay9_reg(0) <= addr_unsigned;
        Delay9_reg(1) <= Delay9_reg(0);
      END IF;
    END IF;
  END PROCESS Delay9_process;

  Delay9_out1 <= Delay9_reg(1);

  Add1_sub_temp <= signed(resize(Delay9_out1, 17)) - to_signed(16#01000#, 17);
  Add1_out1 <= Add1_sub_temp(15 DOWNTO 0);

  Delay11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        index_in <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        index_in <= Add1_out1;
      END IF;
    END IF;
  END PROCESS Delay11_process;


  corr_vout_signed <= signed(corr_vout);

  Delay4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay4_out1 <= to_signed(0, 32);
      ELSIF enb = '1' THEN
        Delay4_out1 <= corr_vout_signed;
      END IF;
    END IF;
  END PROCESS Delay4_process;


  
  Compare_To_Constant_out1 <= '1' WHEN corr_vout_signed >= to_signed(6553600, 32) ELSE
      '0';

  Logical_Operator5_out1 <= correlator1_out3 AND peak_fsm_out1;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 20
  count_20_steps_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        count_20_steps_out1 <= to_unsigned(16#00#, 8);
      ELSIF enb = '1' THEN
        IF Logical_Operator5_out1 = '1' THEN 
          IF count_20_steps_out1 >= to_unsigned(16#14#, 8) THEN 
            count_20_steps_out1 <= to_unsigned(16#00#, 8);
          ELSE 
            count_20_steps_out1 <= count_20_steps_out1 + to_unsigned(16#01#, 8);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS count_20_steps_process;


  
  Compare_To_Constant1_out1 <= '1' WHEN count_20_steps_out1 = to_unsigned(16#14#, 8) ELSE
      '0';

  Logical_Operator7_out1 <= correlator1_out3 AND Compare_To_Constant1_out1;

  stored_index_signed <= signed(stored_index);

  Data_Type_Conversion_out1 <= unsigned(stored_index_signed(14 DOWNTO 0));

  Delay10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay10_out1 <= to_unsigned(16#0000#, 15);
      ELSIF enb = '1' THEN
        Delay10_out1 <= Data_Type_Conversion_out1;
      END IF;
    END IF;
  END PROCESS Delay10_process;


  index <= std_logic_vector(Delay10_out1);

  Logical_Operator3_out1 <=  NOT Compare_To_Constant1_out1;

  Logical_Operator2_out1 <= correlator1_out3 AND Logical_Operator3_out1;

  Delay3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay3_out1 <= Logical_Operator2_out1;
      END IF;
    END IF;
  END PROCESS Delay3_process;


  Delay6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay6_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay6_out1 <= Logical_Operator7_out1;
      END IF;
    END IF;
  END PROCESS Delay6_process;



  step <= Delay3_out1;

  peak_found <= Delay6_out1;

  probe <= corr_vout;

END rtl;

