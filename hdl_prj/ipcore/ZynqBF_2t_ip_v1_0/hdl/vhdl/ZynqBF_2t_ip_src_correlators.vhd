-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ZynqBF_2tx_fpga\ZynqBF_2t_ip_src_peakdetect_ch1.vhd
-- Created: 2019-02-08 23:33:51
-- 
-- Generated by MATLAB 9.5 and HDL Coder 3.13
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ZynqBF_2t_ip_src_peakdetect_ch1
-- Source Path: ZynqBF_2tx_fpga/channel_estimator/peakdetect_ch1
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ZynqBF_2t_ip_src_ZynqBF_2tx_fpga_pkg.ALL;

ENTITY ZynqBF_2t_ip_src_correlators IS
  GENERIC(
        NCORR                             :   integer := 2      -- number of correlators
        );
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        rst                               :   IN    std_logic;
        din_i                             :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15 [2]
        din_q                             :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15 [2]
        vin                               :   IN    std_logic;                      -- rx ram write enable
        est_en                            :   IN    std_logic;
        index                             :   OUT   std_logic_vector(14 DOWNTO 0);  -- ufix15
        step                              :   OUT   std_logic;
        peak_found                        :   OUT   std_logic;
        est_val                           :   OUT   std_logic;                      -- valid signal for ch_est input
        probe                             :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En16
        );
END ZynqBF_2t_ip_src_correlators;


ARCHITECTURE rtl OF ZynqBF_2t_ip_src_correlators IS

  -- Component Declarations
  COMPONENT ZynqBF_2t_ip_src_peak_fsm
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          t_cross                         :   IN    std_logic;
          cnt_end                         :   IN    std_logic;
          scan_peak                       :   OUT   std_logic;
          peak_found                      :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ZynqBF_2t_ip_src_running_max
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          din                             :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En16
          en                              :   IN    std_logic;
          rst                             :   IN    std_logic;
          new_max                         :   OUT   std_logic;
          max_val                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En16
          );
  END COMPONENT;

  -- COMPONENT ZynqBF_2t_ip_src_store_index
    -- PORT( clk                             :   IN    std_logic;
          -- reset                           :   IN    std_logic;
          -- enb                             :   IN    std_logic;
          -- din                             :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
          -- update                          :   IN    std_logic;
          -- dout                            :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          -- );
  -- END COMPONENT;
  
  component ZynqBF_2t_ip_src_rx_bram 
  port( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        din_i                             :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        din_q                             :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        we                                :   IN    std_logic;
        wr_addr                           :   IN    std_logic_vector(14 DOWNTO 0);  -- ufix15
        rd_addr                           :   IN    std_logic_vector(14 DOWNTO 0);  -- ufix15
        shift                             :   IN    std_logic_vector(5 DOWNTO 0);  -- ufix15
        dout_i                            :   OUT   vector_of_std_logic_vector16(0 TO 63);  -- rx i data for the correlators
        dout_q                            :   OUT   vector_of_std_logic_vector16(0 TO 63)   -- rx q data for the correlators
        );
  END COMPONENT;
  
  component ZynqBF_2t_ip_src_goldSeq
  generic (N                              :   integer := 2);
  port( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        addr                              :   IN    std_logic_vector(5 DOWNTO 0);
        gs_out                            :   OUT   vector_of_std_logic_vector16(0 to (N*64 - 1))
        );
  end component;
  
  component ZynqBF_2t_ip_src_shift_rx
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        u                                 :   IN    vector_of_std_logic_vector16(0 TO 63);  -- sfix16_En15 [64]
        shift                             :   IN    std_logic_vector(5 DOWNTO 0);  -- ufix6
        y                                 :   OUT   vector_of_std_logic_vector16(0 TO 63)  -- sfix16_En15 [64]
        );
  END component;
  
  component ZynqBF_2t_ip_src_rx_gs_mult
  generic( N                              :   integer := 2);
  port( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        start                             :   IN    std_logic;
        en                                :   IN    std_logic;  -- enable for MACC
        rxi                               :   IN    vector_of_std_logic_vector16(0 TO 63);  -- rx i data for the correlators
        rxq                               :   IN    vector_of_std_logic_vector16(0 TO 63);  -- rx q data for the correlators
        gsi                               :   IN    vector_of_std_logic_vector16(0 TO (64*N-1));  -- gs i data for the correlators
        gsq                               :   IN    vector_of_std_logic_vector16(0 TO (64*N-1));  -- gs q data for the correlators
        done                              :   OUT   std_logic;
        dout                              :   OUT   vector_of_std_logic_vector32(0 TO (N-1))
        );
  end component;
  
  component ZynqBF_2t_ip_src_ch_est2
  port( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        rxi                               :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15
        rxq                               :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15
        gsi                               :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15
        gsq                               :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15
        en                                :   IN    std_logic;
        ch_i                              :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        ch_q                              :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        done                              :   OUT   std_logic
        );
  end component;
        

  -- Component Configuration Statements
  FOR ALL : ZynqBF_2t_ip_src_peak_fsm
    USE ENTITY work.ZynqBF_2t_ip_src_peak_fsm(rtl);

  FOR ALL : ZynqBF_2t_ip_src_running_max
    USE ENTITY work.ZynqBF_2t_ip_src_running_max(rtl);

  --FOR ALL : ZynqBF_2t_ip_src_store_index
  --  USE ENTITY work.ZynqBF_2t_ip_src_store_index(rtl);
    
  FOR ALL : ZynqBF_2t_ip_src_rx_bram
    USE ENTITY work.ZynqBF_2t_ip_src_rx_bram(rtl);
    
  FOR ALL : ZynqBF_2t_ip_src_goldSeq
    USE ENTITY work.ZynqBF_2t_ip_src_goldSeq(rtl);  
    
  FOR ALL : ZynqBF_2t_ip_src_shift_rx
    USE ENTITY work.ZynqBF_2t_ip_src_shift_rx(rtl);
    
  FOR ALL : ZynqBF_2t_ip_src_rx_gs_mult
    USE ENTITY work.ZynqBF_2t_ip_src_rx_gs_mult(rtl);
 
  FOR ALL : ZynqBF_2t_ip_src_ch_est2
    USE ENTITY work.ZynqBF_2t_ip_src_ch_est2(rtl);

  -- Signals
  SIGNAL addr_unsigned                    : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL Delay9_reg                       : vector_of_unsigned15(0 TO 1);  -- ufix15 [2]
  SIGNAL Delay9_out1                      : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL Add1_sub_temp                    : signed(16 DOWNTO 0);  -- sfix17
  SIGNAL Add1_out1                        : signed(15 DOWNTO 0);  -- int16
  SIGNAL index_in                         : signed(15 DOWNTO 0);  -- int16
  SIGNAL corr_vout                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL correlator1_out2                 : std_logic;
  SIGNAL correlator1_out3                 : std_logic;
  SIGNAL corr_vout_signed                 : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL Delay4_out1                      : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL peak_fsm_out1                    : std_logic;
  SIGNAL Logical_Operator5_out1           : std_logic;
  SIGNAL count_20_steps_out1              : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Compare_To_Constant1_out1        : std_logic;
  SIGNAL Logical_Operator7_out1           : std_logic;
  SIGNAL peak_fsm_out2                    : std_logic;
  -- SIGNAL update_index                     : std_logic;
  SIGNAL running_max_out2                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL stored_index                     : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL stored_index_signed              : signed(15 DOWNTO 0);  -- int16
  SIGNAL Data_Type_Conversion_out1        : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL Delay10_out1                     : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL Logical_Operator3_out1           : std_logic;
  SIGNAL Logical_Operator2_out1           : std_logic;
  SIGNAL Delay3_out1                      : std_logic;
  SIGNAL Delay6_out1                      : std_logic;
  
  signal rxi                              : vector_of_std_logic_vector16(0 to 63);
  signal rxq                              : vector_of_std_logic_vector16(0 to 63);
  signal gsdata                           : vector_of_std_logic_vector16(0 to (64*NCORR - 1));
  signal gsi                              : vector_of_std_logic_vector16(0 to (64*NCORR - 1));
  signal gsq                              : vector_of_std_logic_vector16(0 to (64*NCORR - 1));
  signal rxi_shifted                      : vector_of_std_logic_vector16(0 to 63);
  signal rxq_shifted                      : vector_of_std_logic_vector16(0 to 63);
  
  signal rx_sel                           : integer range 0 to 63;
  
  signal vin_dreg                         : std_logic_vector(2 downto 0);   -- 3 stage delay register for vin signal
  signal inc_rx_ram_wraddr                : std_logic;                      -- flag to increment the rx ram wr addr
  
  signal corr_start                       : std_logic;
  signal corr_start_dreg                  : std_logic_vector(2 downto 0);   -- 3 stage delay register for corr start signal
  signal corr_start_d3                    : std_logic;
  signal corr_en                          : std_logic;
  signal corr_en_d3                       : std_logic;
  signal corr_en_dreg                     : std_logic_vector(2 downto 0);   -- 3 stage delay register for corr en signal
  signal rx_ram_re                        : std_logic;
  signal rx_ram_wraddr                    : std_logic_vector(14 downto 0);
  signal rx_ram_rdaddr                    : std_logic_vector(14 downto 0);
  signal gs_ram_rdaddr                    : std_logic_vector(5 downto 0);
  signal rx_in_addr                       : unsigned(14 downto 0);
  signal shift_cnt                        : unsigned(5 downto 0);
  
  signal pd_rxaddr                        : std_logic_vector(14 downto 0);
  signal pd_gsaddr                        : std_logic_vector(5 downto 0);
  
  signal corr_shift                       : unsigned(5 downto 0);           -- latch value of shift_cnt at the start of the correlation
  signal corr_cnt                         : unsigned(11 downto 0);          -- correlation counter (and address for gs ram, address offset for rx ram)
  signal corr_base                        : unsigned(14 downto 0);          -- correlation base address for rx ram

  signal corr_done                        : std_logic;
  signal corr_dout                        : vector_of_std_logic_vector32(0 to (NCORR-1));
  
  -- peak tracking fsm/
  -- signal cs_ptrack                        : std_logic_vector(2 downto 0);
  signal cs_ptrack                        : vector_of_std_logic_vector3(0 to (NCORR-1));
  constant s_wait                         : std_logic_vector(2 downto 0) := "001";
  constant s_track                        : std_logic_vector(2 downto 0) := "010";
  constant s_finish                       : std_logic_vector(2 downto 0) := "100";
  
  signal ptrack_ind                       : integer range 0 to (NCORR-1);   -- index of which correlator has a peak detected
  signal ptrack_addr_in                   : unsigned(14 downto 0);
  signal ptrack_start                     : unsigned(0 to (NCORR-1));
  signal ptrack_en                        : unsigned(0 to (NCORR-1));
  signal ptrack_cnt                       : vector_of_unsigned8(0 to (NCORR-1));
  constant PTRACK_CNT_END                 : unsigned(7 downto 0) := x"40";  -- look for peak across 64 samples
  
  signal ram_index                        : std_logic_vector(14 downto 0);
  signal update_est_index                 : std_logic_vector(0 to (NCORR-1));
  signal est_index_start                  : vector_of_std_logic_vector15(0 to (NCORR-1));
  
  signal corr_threshold                   : vector_of_std_logic_vector32(0 to (NCORR-1));
  constant corr_thresh_const              : vector_of_std_logic_vector32(0 to (NCORR-1)) := (others => x"01000000");
  
  signal cs_main                          : vector_of_std_logic_vector8(0 to (NCORR-1));    -- main FSM
  constant s_peakdetect                   : std_logic_vector(3 downto 0) := "00000001";
  constant s_wait2                        : std_logic_vector(3 downto 0) := "00000010";
  constant s_channelest                   : std_logic_vector(3 downto 0) := "00000100";
  constant s_wait3                        : std_logic_vector(3 downto 0) := "00001000";
  constant s_reset                        : std_logic_vector(3 downto 0) := "00010000";
  
  
  signal ch_est_en                        : unsigned(0 to (NCORR-1));
  --signal ch_est_valid                     : std_logic_vector(0 to (NCORR-1));
  --signal ch_est_last                      : std_logic_vector(0 to (NCORR-1));
  signal ch_est_done                      : std_logic_vector(0 to (NCORR-1));
  signal ch_est_rxaddr                    : std_logic_vector(14 downto 0);
  signal ch_est_gsaddr                    : std_logic_vector(11 downto 0);
  
BEGIN

  gsi <= gsdata;
  gsq <= gsdata;
  corr_threshold <= corr_thresh_const;
  ram_index <= std_logic_vector(unsigned(rx_ram_wraddr) - to_unsigned(16#1000#, 14));
  rx_sel <= to_integer(unsigned(rx_ram_rdaddr(5 downto 0)));
  
--  rx_ram_rdaddr <= std_logic_vector(corr_cnt + corr_base);
--  gs_ram_rdaddr <= std_logic_vector(corr_cnt(11 downto 6));
  pd_rxaddr <= std_logic_vector(corr_cnt + corr_base);
  pd_gsaddr <= std_logic_vector(corr_cnt(11 downto 6));
  
  rx_ram_rdaddr <= ch_est_rxaddr when ch_est_en > to_unsigned(16#0#, NCORR) else pd_rxaddr;
  gs_ram_rdaddr <= ch_est_gsaddr(11 downto 6) when ch_est_en > to_unsigned(16#0#, NCORR) else pd_gsaddr;

  u_rx_bram : ZynqBF_2t_ip_src_rx_bram
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              din_i => din_i,
              din_q => din_q,
              we => vin,
              wr_addr => rx_ram_wraddr,
              rd_addr => rx_ram_rdaddr,
              shift => std_logic_vector(corr_shift),
              dout_i => rxi,
              dout_q => rxq
              );
              
  u_gs : ZynqBF_2t_ip_src_goldSeq
    GENERIC MAP (N => NCORR)
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              addr => gs_ram_rdaddr,
              gs_out => gsdata
              );
              
  u_shift_rxi : ZynqBF_2t_ip_src_shift_rx
    PORT MAP( clk => clk,
              reset => reset,
              u => rxi,
              shift => std_logic_vector(corr_shift),
              y => rxi_shifted
              );
  
  u_shift_rxq : ZynqBF_2t_ip_src_shift_rx
    PORT MAP( clk => clk,
              reset => reset,
              u => rxq,
              shift => std_logic_vector(corr_shift),
              y => rxq_shifted
              );
  
  test_macc : ZynqBF_2t_ip_src_rx_gs_mult
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              start => corr_start_d3,
              en => corr_en_d3,
              rxi => rxi_shifted,
              rxq => rxq_shifted,
              gsi => gsi,
              gsq => gsq,
              done => corr_done,
              dout => corr_dout
              );

  u_peak_fsm : ZynqBF_2t_ip_src_peak_fsm
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              t_cross => Compare_To_Constant_out1,
              cnt_end => Logical_Operator7_out1,
              scan_peak => peak_fsm_out1,
              peak_found => peak_fsm_out2
              );

              
  gen_running_max: for i in 0 to (NCORR-1) generate
    u_running_max_i : ZynqBF_2t_ip_src_running_max
      PORT MAP( clk => clk,
                reset => reset,
                enb => enb,
                din => corr_dout(i),  -- sfix32_En16
                en => cs_ptrack(i)(1),
                rst => cs_ptrack(i)(2),
                new_max => update_est_index(i),
                max_val => open  -- sfix32_En16
                );
  end generate;
  
  gen_ch_est: for i in 0 to (NCORR-1) generate
    u_ch_est_i : ZynqBF_2t_ip_src_ch_est2
      PORT MAP( clk => clk,
                reset => reset,
                enb => enb,
                rxi => rxi(rx_sel),
                rxq => rxq(rx_sel),
                gsi => 
                gsq => 
                en => 
                ch_i =>
                ch_q =>
                done =>
                );
  end generate;
                  

  vin_delay_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            vin_dreg <= "000";
        elsif enb = '1' then
            vin_dreg <= vin_dreg(1 downto 0) & vin;
        end if;
    end if;
  end process;
  
  corr_start <= vin_dreg(1);
  inc_rx_ram_wraddr <= vin_dreg(2);
  
  addr_in_counters_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' or rst = '1' then
            rx_in_addr <= (others => '0');
            shift_cnt <= (others => '0');
        elsif enb = '1' and inc_rx_ram_wraddr = '1' then
            if rx_in_addr = "111000000000000" then
                rx_in_addr <= (others => '0');
            else
                rx_in_addr <= rx_in_addr + 1;
            end if;
            shift_cnt <= shift_cnt + 1;
        end if;
    end if;
  end process;
  
  rx_ram_wraddr <= std_logic_vector(rx_in_addr + "000111111111111");
  
  correlation_enable_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            corr_en <= '0';
        elsif enb = '1' then
            if corr_done = '1' then
                corr_en <= '0';
            elsif corr_start = '1' then
                corr_en <= '1';
            end if;
        end if;
    end if;
  end process;
  
  corr_start_delay : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            corr_start_dreg <= (others => '0');
        elsif enb = '1' then
            corr_start_dreg <= corr_start_dreg(corr_start_dreg'high-1 downto 0) & corr_start;
        end if;
    end if;
  end process;
  
  corr_start_d3 <= corr_start_dreg(2);
  
  corr_en_delay_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            corr_en_dreg <= (others => '0');
        elsif enb = '1' then
            corr_en_dreg <= corr_en_dreg(corr_en_dreg'high-1 downto 0) & corr_en;
        end if;
    end if;
  end process;
  
  corr_en_d3 <= corr_en_dreg(2);
  
  correlation_control_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            corr_shift <= (others => '0');
            corr_cnt <= (others => '0');
            corr_base <= (others => '0');
        elsif enb = '1' then
            if corr_start = '1' then
                corr_shift <= shift_cnt;
                corr_cnt <= (others => '0');
                corr_base <= rx_in_addr;
            elsif corr_en = '1' then
                corr_shift <= corr_shift;
                corr_cnt <= corr_cnt + 64;  -- increment by the number of parallel DSPs for each correlator iteration
                corr_base <= corr_base;
            else
                corr_shift <= corr_shift;
                corr_cnt <= (others => '0');
                corr_base <= corr_base;
            end if;
        end if;
    end if;
  end process;
  
  detect_threshold_crossing : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            ptrack_start <= (others => '0');
            ptrack_ind <= 0;
        elsif enb = '1' then 
            for i in 0 to (NCORR-1) loop
                if cs_ptrack(i) = s_wait then
                    if signed(corr_dout(i)) >= signed(corr_threshold(i)) then
                        ptrack_start(i) <= '1';
                    else
                        ptrack_start(i) <= '0';
                    end if;
                else
                    ptrack_start(i) <= '0';
                end if;
            end loop;
        end if;
    end if;
  end process;
  
  ptrack_enable_register : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            ptrack_en <= (others => '0');
        elsif enb = '1' then
            for i in 0 to (NCORR-1) loop
                if cs_ptrack(i) = s_track then
                    ptrack_en(i) <= '1';
                else
                    ptrack_en(i) <= '0';
                end if;
            end loop;
        end if;
    end if;
  end process;
  
  peak_tracking_fsm : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            for i in 0 to (NCORR-1) loop
                cs_ptrack(i) <= s_wait;
            end loop;
        elsif enb = '1' then
            for i in 0 to (NCORR-1) loop
                case cs_ptrack(i) is
                    when s_wait =>
                        if ptrack_start(i) = '1' then
                            cs_ptrack(i) <= s_track;
                        else
                            cs_ptrack(i) <= s_wait;
                        end if;
                    when s_track =>
                        if ptrack_cnt(i) >= PTRACK_CNT_END and corr_done = '1' then
                            cs_ptrack(i) <= s_finish;
                        else
                            cs_ptrack(i) <= s_track;
                        end if;
                    when s_finish =>
                        cs_ptrack(i) <= s_wait;
                    when others =>
                        cs_ptrack(i) <= s_wait;
                end case;
            end loop;
        end if;
    end if;
  end process;
  
  peak_track_counter : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            for i in 0 to (NCORR-1) loop
                ptrack_cnt(i) <= x"00";
            end loop;
        elsif enb = '1' then 
            for i in 0 to (NCORR-1) loop 
                if cs_ptrack(i) = s_track then
                    if corr_done = '1' then
                        ptrack_cnt(i) <= ptrack_cnt(i) + 1;
                    end if;
                else
                    ptrack_cnt(i) <= x"00";
                end if;
            end loop;
        end if;
    end if;
  end process;
  
  index_of_max_corr : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            est_index_start <= (others => (others => '0'));
        elsif enb = '1' then
            for i in 0 to (NCORR-1) loop
                if update_est_index(i) = '1' then
                    est_index_start(i) <= ram_index;
                end if;
            end loop;
        end if;
    end if;
  end process;
  
  main_fsm : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            cs_main <= (others => s_peakdetect);
        elsif enb = '1' then
            for i in 0 to (NCORR-1) loop
                case cs_main(i) is
                    when s_peakdetect =>
                        if cs_ptrack(i) = s_finish then
                            cs_main(i) <= s_wait2;
                        else
                            cs_main(i) <= s_peakdetect;
                        end if;
                    when s_wait2 =>
                            if ptrack_en > to_unsigned(16#0#, NCORR) then
                                cs_main(i) <= s_wait2;
                            else
                                cs_main(i) <= s_channelest;
                            end if;
                    when s_channelest =>
                        if ch_est_done(i) = '1' then
                            cs_main(i) <= s_wait3;
                        else
                            cs_main(i) <= s_channelest;
                        end if;
                    when s_wait3 =>
                        if ch_est_en > to_unsigned(16#0#, NCORR) then
                            cs_main(i) <= s_wait3;
                        else
                            cs_main(i) <= s_reset;
                        end if;
                    when s_reset =>
                        cs_main(i) <= s_peakdetect;
                    when others =>
                        cs_main(i) <= s_peakdetect;
                end case;
            end loop;
        end if;
    end if;
  end process;
                            

  Delay9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay9_reg <= (OTHERS => to_unsigned(16#0000#, 15));
      ELSIF enb = '1' THEN
        Delay9_reg(0) <= addr_unsigned;
        Delay9_reg(1) <= Delay9_reg(0);
      END IF;
    END IF;
  END PROCESS Delay9_process;

  Delay9_out1 <= Delay9_reg(1);

  Add1_sub_temp <= signed(resize(Delay9_out1, 17)) - to_signed(16#01000#, 17);
  Add1_out1 <= Add1_sub_temp(15 DOWNTO 0);

  Delay11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        index_in <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        index_in <= Add1_out1;
      END IF;
    END IF;
  END PROCESS Delay11_process;


  corr_vout_signed <= signed(corr_vout);

  Delay4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay4_out1 <= to_signed(0, 32);
      ELSIF enb = '1' THEN
        Delay4_out1 <= corr_vout_signed;
      END IF;
    END IF;
  END PROCESS Delay4_process;


  
  Compare_To_Constant_out1 <= '1' WHEN corr_vout_signed >= to_signed(6553600, 32) ELSE
      '0';

  Logical_Operator5_out1 <= correlator1_out3 AND peak_fsm_out1;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 20
  count_20_steps_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        count_20_steps_out1 <= to_unsigned(16#00#, 8);
      ELSIF enb = '1' THEN
        IF Logical_Operator5_out1 = '1' THEN 
          IF count_20_steps_out1 >= to_unsigned(16#14#, 8) THEN 
            count_20_steps_out1 <= to_unsigned(16#00#, 8);
          ELSE 
            count_20_steps_out1 <= count_20_steps_out1 + to_unsigned(16#01#, 8);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS count_20_steps_process;


  
  Compare_To_Constant1_out1 <= '1' WHEN count_20_steps_out1 = to_unsigned(16#14#, 8) ELSE
      '0';

  Logical_Operator7_out1 <= correlator1_out3 AND Compare_To_Constant1_out1;

  stored_index_signed <= signed(stored_index);

  Data_Type_Conversion_out1 <= unsigned(stored_index_signed(14 DOWNTO 0));

  Delay10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay10_out1 <= to_unsigned(16#0000#, 15);
      ELSIF enb = '1' THEN
        Delay10_out1 <= Data_Type_Conversion_out1;
      END IF;
    END IF;
  END PROCESS Delay10_process;


  index <= std_logic_vector(Delay10_out1);

  Logical_Operator3_out1 <=  NOT Compare_To_Constant1_out1;

  Logical_Operator2_out1 <= correlator1_out3 AND Logical_Operator3_out1;

  Delay3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay3_out1 <= Logical_Operator2_out1;
      END IF;
    END IF;
  END PROCESS Delay3_process;


  Delay6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay6_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay6_out1 <= Logical_Operator7_out1;
      END IF;
    END IF;
  END PROCESS Delay6_process;

END rtl;

