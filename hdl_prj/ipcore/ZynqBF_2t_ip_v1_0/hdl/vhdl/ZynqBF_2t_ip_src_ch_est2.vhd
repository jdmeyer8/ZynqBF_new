-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ZynqBF_2tx_fpga\ZynqBF_2t_ip_src_ch_est.vhd
-- Created: 2019-02-08 23:33:52
-- 
-- Generated by MATLAB 9.5 and HDL Coder 3.13
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ZynqBF_2t_ip_src_ch_est
-- Source Path: ZynqBF_2tx_fpga/channel_estimator/ch_est
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ZynqBF_2t_ip_src_ZynqBF_2tx_fpga_pkg.ALL;

ENTITY ZynqBF_2t_ip_src_ch_est2 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        rxi                               :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15
        rxq                               :   IN    std_logic_vector(15 downto 0);
        gsi                               :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15
        gsq                               :   IN    std_logic_vector(15 downto 0);
        en                                :   IN    std_logic;
        base_addr                         :   IN    std_logic_vector(14 downto 0);
        rx_addr                           :   IN    std_logic_vector(14 downto 0);
        gs_addr_msb                       :   OUT   std_logic_vector(5 downto 0);
        gs_addr_lsb                       :   OUT   std_logic_vector(5 downto 0);
        ch_i                              :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        ch_q                              :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        done                              :   OUT   std_logic
        );
END ZynqBF_2t_ip_src_ch_est2;


ARCHITECTURE rtl OF ZynqBF_2t_ip_src_ch_est2 IS

  COMPONENT ZynqBF_2t_ip_src_nr_reciprocal
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          din                             :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En16
          start                           :   IN    std_logic;
          dout                            :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En14
          valid                           :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ZynqBF_2t_ip_src_ch_est_mac
    PORT( clk                               :   IN    std_logic;
          reset                             :   IN    std_logic;
          enb                               :   IN    std_logic;
          start                             :   IN    std_logic;
          en                                :   IN    std_logic;
          last                              :   IN    std_logic;
          din1                              :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15
          din2                              :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15
          ready                             :   OUT   std_logic;
          dout                              :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En14
          );
    END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : ZynqBF_2t_ip_src_nr_reciprocal
    USE ENTITY work.ZynqBF_2t_ip_src_nr_reciprocal(rtl);
    
  FOR ALL : ZynqBF_2t_ip_src_ch_est_mac
        USE ENTITY work.ZynqBF_2t_ip_src_ch_est_mac(rtl);
    
  signal a, b, c, d                         : std_logic_vector(15 downto 0);
  signal macc_ac, macc_bd                   : std_logic_vector(31 downto 0);
  signal macc_ad, macc_bc                   : std_logic_vector(31 downto 0);
  signal macc_done                          : std_logic_vector(5 downto 0);
  signal sum_aabb                           : signed(31 downto 0);
  
  -- dot product signals
  signal dp_start                           : std_logic;
  signal dp_en                              : std_logic;
  signal dp_last                            : std_logic;
  signal dp_done                            : std_logic;
  signal dp_done_reg                        : unsigned(0 to 5);
  signal dp_count                           : unsigned(11 downto 0);
  
  -- newton-raphson signals
  signal nr_done                            : std_logic;
  signal nr_dout                            : std_logic_vector(31 downto 0);
  signal nr_signed                          : signed(31 downto 0);
  
  -- state machine signals
  signal cs_est                             : std_logic_vector(3 downto 0);
  constant s_wait                           : std_logic_vector(3 downto 0) := "0001";
  constant s_dp                             : std_logic_vector(3 downto 0) := "0010";
  constant s_nr                             : std_logic_vector(3 downto 0) := "0100";
  constant s_done                           : std_logic_vector(3 downto 0) := "1000";
  

BEGIN
    
    done <= '1' when cs_est = s_done else '0';
    nr_signed <= signed(nr_dout);
    gs_addr_msb <= std_logic_vector(dp_count(11 downto 6));
    gs_addr_lsb <= std_logic_vector(dp_count(5 downto 0));
    dp_start <= '1' when cs_est = s_wait and en = '1' else '0';
    dp_en <= '1' when cs_est = s_dp else '0';
    dp_last <= '1' when cs_est = s_dp and dp_count = to_unsigned(16#0fff#, dp_count'high+1) else '0';
    dp_done <= '1' when dp_done_reg > to_unsigned(16#0#, dp_done_reg'high+1) else '0';
    
    u_nr_reciprocal : ZynqBF_2t_ip_src_nr_reciprocal
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              din => std_logic_vector(sum_aabb),
              start => dp_done,
              dout => nr_dout,
              valid => nr_done
              );
              
   ac_macc_inst : ZynqBF_2t_ip_src_ch_est_mac
   PORT MAP( clk => clk,
             reset => reset,
             enb => enb,
             start => dp_start,
             en => dp_en,
             last => dp_last, 
             din1 => a,
             din2 => b,
             ready => dp_done_reg(0),
             dout => macc_ac
             );
              

    register_inputs: process(clk)
    begin
        if clk'event and clk = '1' then
            if reset = '1' then
                a <= (others => '0');
                b <= (others => '0');
                c <= (others => '0');
                d <= (others => '0');
            elsif enb = '1' then
                if en = '1' then
                    a <= gsi;
                    b <= gsq;
                    c <= rxi;
                    d <= rxq;
                end if;
            end if;
        end if;
    end process;
    
    state_machine : process(clk)
    begin
        if clk'event and clk = '1' then
            if reset = '1' then
                cs_est <= s_wait;
            elsif enb = '1' then
                case cs_est is
                    when s_wait =>
                        if en = '1' then
                            cs_est <= s_dp;
                        else
                            cs_est <= s_wait;
                        end if;
                    when s_dp =>
                        if unsigned(macc_done) > to_unsigned(16#0#, 6) then
                            cs_est <= s_nr;
                        else
                            cs_est <= s_dp;
                        end if;
                    when s_nr =>
                        if nr_done = '1' then
                            cs_est <= s_done;
                        else
                            cs_est <= s_nr;
                        end if;
                    when s_done =>
                        cs_est <= s_wait;
                    when others =>
                        cs_est <= s_wait;
                end case;
            end if;
        end if;
    end process;
    
    dotproduct_counter : process(clk)
    begin
        if clk'event and clk = '1' then
            if reset = '1' then
                dp_count <= (others => '0');
            elsif enb = '1' then
                if dp_en = '1' then
                    dp_count <= dp_count + 1;
                else
                    dp_count <= (others => '0');
                end if;
            end if;
        end if;
    end process;

END rtl;

